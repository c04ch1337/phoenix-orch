use crate::{Threat, ThreatDetector, IncidentReport, ThreatSeverity};
use async_trait::async_trait;
use std::error::Error;
use std::collections::HashMap;
use tokio::sync::RwLock;
use std::sync::Arc;

pub struct NetworkIDS {
    rules: Arc<RwLock<HashMap<String, Rule>>>,
    threshold: u32,
    detection_window: chrono::Duration,
    last_detection: chrono::DateTime<chrono::Utc>,
}

#[derive(Clone, Debug)]
struct Rule {
    pattern: String,
    severity: ThreatSeverity,
    description: String,
    counter: u32,
}

impl NetworkIDS {
    pub fn new(threshold: u32, detection_window_secs: i64) -> Self {
        Self {
            rules: Arc::new(RwLock::new(HashMap::new())),
            threshold,
            detection_window: chrono::Duration::seconds(detection_window_secs),
            last_detection: chrono::Utc::now(),
        }
    }

    pub async fn add_rule(&self, pattern: String, severity: ThreatSeverity, description: String) {
        let mut rules = self.rules.write().await;
        rules.insert(pattern.clone(), Rule {
            pattern,
            severity,
            description,
            counter: 0,
        });
    }

    pub async fn process_network_packet(&self, packet: &[u8]) -> Option<Threat> {
        let packet_str = String::from_utf8_lossy(packet);
        let mut rules = self.rules.write().await;
        
        for rule in rules.values_mut() {
            if packet_str.contains(&rule.pattern) {
                rule.counter += 1;
                
                if rule.counter >= self.threshold {
                    let now = chrono::Utc::now();
                    if now - self.last_detection >= self.detection_window {
                        return Some(Threat {
                            id: uuid::Uuid::new_v4(),
                            severity: rule.severity,
                            description: format!("Network IDS Alert: {}", rule.description),
                            timestamp: now,
                            source: "NetworkIDS".to_string(),
                        });
                    }
                }
            }
        }
        None
    }

    async fn analyze_threat_pattern(&self, threat: &Threat) -> Result<IncidentReport, Box<dyn Error + Send + Sync>> {
        Ok(IncidentReport {
            id: uuid::Uuid::new_v4(),
            threat: threat.clone(),
            status: crate::IncidentStatus::Analyzing,
            actions_taken: vec![
                "Pattern analysis initiated".to_string(),
                "Network traffic correlation in progress".to_string(),
            ],
            evidence: vec![],
            timestamp: chrono::Utc::now(),
        })
    }
}

#[async_trait]
impl ThreatDetector for NetworkIDS {
    async fn detect(&self) -> Result<Vec<Threat>, Box<dyn Error + Send + Sync>> {
        // In a real implementation, this would continuously monitor network traffic
        // For now, we'll return an empty vec as threats are generated by process_network_packet
        Ok(Vec::new())
    }

    async fn analyze(&self, threat: &Threat) -> Result<IncidentReport, Box<dyn Error + Send + Sync>> {
        self.analyze_threat_pattern(threat).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_ids_rule_matching() {
        let ids = NetworkIDS::new(1, 60);
        
        ids.add_rule(
            "MALICIOUS".to_string(),
            ThreatSeverity::High,
            "Detected malicious pattern".to_string()
        ).await;

        let packet = b"This is a MALICIOUS test packet";
        let threat = ids.process_network_packet(packet).await.unwrap();
        
        assert_eq!(threat.severity, ThreatSeverity::High);
        assert!(threat.description.contains("Network IDS Alert"));
    }

    #[tokio::test]
    async fn test_ids_threshold() {
        let ids = NetworkIDS::new(2, 60);
        
        ids.add_rule(
            "SUSPICIOUS".to_string(),
            ThreatSeverity::Medium,
            "Detected suspicious pattern".to_string()
        ).await;

        let packet = b"This is a SUSPICIOUS test packet";
        
        // First detection shouldn't trigger an alert
        assert!(ids.process_network_packet(packet).await.is_none());
        
        // Second detection should trigger an alert
        let threat = ids.process_network_packet(packet).await.unwrap();
        assert_eq!(threat.severity, ThreatSeverity::Medium);
    }
}