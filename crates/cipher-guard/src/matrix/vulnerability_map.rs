//! Vulnerability Defense Map Architecture
//! 
//! Maps vulnerabilities to defenses and threat actors for comprehensive defense planning

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};

/// Vulnerability Defense Map structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityDefenseMap {
    pub vulnerabilities: HashMap<String, Vulnerability>,
    pub defenses: HashMap<String, DefensePosture>,
    pub threat_actors: HashMap<String, ThreatActor>,
    pub attack_vectors: HashMap<String, AttackVector>,
    pub last_updated: DateTime<Utc>,
    pub coverage_score: f64,
}

impl VulnerabilityDefenseMap {
    /// Create a new vulnerability defense map
    pub fn new() -> Self {
        Self {
            vulnerabilities: HashMap::new(),
            defenses: HashMap::new(),
            threat_actors: HashMap::new(),
            attack_vectors: HashMap::new(),
            last_updated: Utc::now(),
            coverage_score: 0.0,
        }
    }

    /// Calculate overall coverage score
    pub fn calculate_coverage(&mut self) -> f64 {
        if self.vulnerabilities.is_empty() {
            self.coverage_score = 0.0;
            return 0.0;
        }

        let total_vulnerabilities = self.vulnerabilities.len() as f64;
        let covered_vulnerabilities = self.vulnerabilities.values()
            .filter(|vuln| {
                self.defenses.values()
                    .any(|defense| defense.covers_vulnerability(vuln))
            })
            .count() as f64;

        self.coverage_score = covered_vulnerabilities / total_vulnerabilities;
        self.coverage_score
    }

    /// Add a vulnerability to the map
    pub fn add_vulnerability(&mut self, vulnerability: Vulnerability) {
        self.vulnerabilities.insert(vulnerability.cve_id.clone(), vulnerability);
        self.last_updated = Utc::now();
        self.calculate_coverage();
    }

    /// Add a defense posture to the map
    pub fn add_defense(&mut self, defense: DefensePosture) {
        self.defenses.insert(defense.id.clone(), defense);
        self.last_updated = Utc::now();
        self.calculate_coverage();
    }

    /// Add a threat actor to the map
    pub fn add_threat_actor(&mut self, threat_actor: ThreatActor) {
        self.threat_actors.insert(threat_actor.name.clone(), threat_actor);
        self.last_updated = Utc::now();
    }

    /// Add an attack vector to the map
    pub fn add_attack_vector(&mut self, attack_vector: AttackVector) {
        self.attack_vectors.insert(attack_vector.name.clone(), attack_vector);
        self.last_updated = Utc::now();
    }

    /// Get vulnerabilities by severity
    pub fn get_vulnerabilities_by_severity(&self, min_severity: f64) -> Vec<&Vulnerability> {
        self.vulnerabilities.values()
            .filter(|vuln| vuln.cvss_score >= min_severity)
            .collect()
    }

    /// Get defenses for a specific vulnerability
    pub fn get_defenses_for_vulnerability(&self, cve_id: &str) -> Vec<&DefensePosture> {
        if let Some(vulnerability) = self.vulnerabilities.get(cve_id) {
            self.defenses.values()
                .filter(|defense| defense.covers_vulnerability(vulnerability))
                .collect()
        } else {
            Vec::new()
        }
    }

    /// Get threat actors targeting specific systems
    pub fn get_threat_actors_for_systems(&self, systems: &[String]) -> Vec<&ThreatActor> {
        self.threat_actors.values()
            .filter(|actor| {
                actor.targets.iter()
                    .any(|target| systems.contains(&target.system_type))
            })
            .collect()
    }
}

/// Vulnerability structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub cve_id: String,
    pub description: String,
    pub cvss_score: f64,
    pub affected_systems: Vec<String>,
    pub exploit_availability: ExploitAvailability,
    pub patch_status: PatchStatus,
    pub compensating_controls: Vec<CompensatingControl>,
    pub published_date: DateTime<Utc>,
    pub last_modified: DateTime<Utc>,
}

impl Vulnerability {
    pub fn new(
        cve_id: String,
        description: String,
        cvss_score: f64,
        affected_systems: Vec<String>,
    ) -> Self {
        Self {
            cve_id,
            description,
            cvss_score,
            affected_systems,
            exploit_availability: ExploitAvailability::Unknown,
            patch_status: PatchStatus::NotPatched,
            compensating_controls: Vec::new(),
            published_date: Utc::now(),
            last_modified: Utc::now(),
        }
    }

    /// Check if vulnerability is critical
    pub fn is_critical(&self) -> bool {
        self.cvss_score >= 9.0
    }

    /// Check if vulnerability is high severity
    pub fn is_high_severity(&self) -> bool {
        self.cvss_score >= 7.0
    }

    /// Check if vulnerability has available exploit
    pub fn has_exploit(&self) -> bool {
        matches!(self.exploit_availability, ExploitAvailability::Public | ExploitAvailability::Private)
    }
}

/// Defense Posture structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DefensePosture {
    pub id: String,
    pub name: String,
    pub description: String,
    pub preventive_controls: Vec<PreventiveControl>,
    pub detective_controls: Vec<DetectiveControl>,
    pub corrective_controls: Vec<CorrectiveControl>,
    pub effectiveness_score: f64,
    pub coverage_percentage: f64,
    pub implementation_status: ImplementationStatus,
}

impl DefensePosture {
    pub fn new(id: String, name: String, description: String) -> Self {
        Self {
            id,
            name,
            description,
            preventive_controls: Vec::new(),
            detective_controls: Vec::new(),
            corrective_controls: Vec::new(),
            effectiveness_score: 0.0,
            coverage_percentage: 0.0,
            implementation_status: ImplementationStatus::Planned,
        }
    }

    /// Check if this defense covers a specific vulnerability
    pub fn covers_vulnerability(&self, vulnerability: &Vulnerability) -> bool {
        // Check if any preventive control covers the vulnerability
        self.preventive_controls.iter()
            .any(|control| control.covers_vulnerability(vulnerability)) ||
        // Check if detective controls can detect exploitation
        self.detective_controls.iter()
            .any(|control| control.can_detect_exploitation(vulnerability)) ||
        // Check if corrective controls can remediate
        self.corrective_controls.iter()
            .any(|control| control.can_remediate(vulnerability))
    }

    /// Calculate overall effectiveness score
    pub fn calculate_effectiveness(&mut self) -> f64 {
        let preventive_score: f64 = self.preventive_controls.iter()
            .map(|c| c.effectiveness)
            .sum::<f64>() / self.preventive_controls.len().max(1) as f64;

        let detective_score: f64 = self.detective_controls.iter()
            .map(|c| c.detection_rate)
            .sum::<f64>() / self.detective_controls.len().max(1) as f64;

        let corrective_score: f64 = self.corrective_controls.iter()
            .map(|c| c.remediation_effectiveness)
            .sum::<f64>() / self.corrective_controls.len().max(1) as f64;

        self.effectiveness_score = (preventive_score * 0.4 + detective_score * 0.3 + corrective_score * 0.3);
        self.effectiveness_score
    }
}

/// Threat Actor structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatActor {
    pub name: String,
    pub motivation: ThreatMotivation,
    pub capabilities: ThreatCapabilities,
    pub targets: Vec<TargetProfile>,
    pub tactics: Vec<super::kill_chain::MitreTactic>,
    pub known_tools: Vec<String>,
    pub attribution_confidence: f64,
}

impl ThreatActor {
    pub fn new(name: String, motivation: ThreatMotivation) -> Self {
        Self {
            name,
            motivation,
            capabilities: ThreatCapabilities::new(),
            targets: Vec::new(),
            tactics: Vec::new(),
            known_tools: Vec::new(),
            attribution_confidence: 0.0,
        }
    }

    /// Check if actor targets specific system types
    pub fn targets_system_type(&self, system_type: &str) -> bool {
        self.targets.iter()
            .any(|target| target.system_type == system_type)
    }

    /// Get actor's capability level
    pub fn capability_level(&self) -> CapabilityLevel {
        self.capabilities.overall_level()
    }
}

/// Attack Vector structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AttackVector {
    pub name: String,
    pub description: String,
    pub complexity: AttackComplexity,
    pub prerequisites: Vec<Prerequisite>,
    pub detection_difficulty: DetectionDifficulty,
    pub success_rate: f64,
}

impl AttackVector {
    pub fn new(name: String, description: String) -> Self {
        Self {
            name,
            description,
            complexity: AttackComplexity::Low,
            prerequisites: Vec::new(),
            detection_difficulty: DetectionDifficulty::Easy,
            success_rate: 0.0,
        }
    }

    /// Check if attack vector is sophisticated
    pub fn is_sophisticated(&self) -> bool {
        matches!(self.complexity, AttackComplexity::High | AttackComplexity::VeryHigh)
    }
}

// Supporting structures and enums
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompensatingControl {
    pub name: String,
    pub description: String,
    pub effectiveness: f64,
    pub implementation_status: ImplementationStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PreventiveControl {
    pub name: String,
    pub control_type: PreventiveControlType,
    pub effectiveness: f64,
    pub coverage: f64,
}

impl PreventiveControl {
    pub fn covers_vulnerability(&self, vulnerability: &Vulnerability) -> bool {
        // Implementation would check if this control type is effective against the vulnerability
        // This is a simplified implementation
        self.effectiveness > 0.5 && self.coverage > 0.7
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DetectiveControl {
    pub name: String,
    pub detection_rate: f64,
    pub false_positive_rate: f64,
    pub response_time: Duration,
}

impl DetectiveControl {
    pub fn can_detect_exploitation(&self, vulnerability: &Vulnerability) -> bool {
        self.detection_rate > 0.7 && self.false_positive_rate < 0.1
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CorrectiveControl {
    pub name: String,
    pub remediation_effectiveness: f64,
    pub time_to_remediate: Duration,
    pub automation_level: AutomationLevel,
}

impl CorrectiveControl {
    pub fn can_remediate(&self, vulnerability: &Vulnerability) -> bool {
        self.remediation_effectiveness > 0.6
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatCapabilities {
    pub technical_skill: f64,
    pub resources: f64,
    pub persistence: f64,
    pub stealth: f64,
}

impl ThreatCapabilities {
    pub fn new() -> Self {
        Self {
            technical_skill: 0.0,
            resources: 0.0,
            persistence: 0.0,
            stealth: 0.0,
        }
    }

    pub fn overall_level(&self) -> CapabilityLevel {
        let avg = (self.technical_skill + self.resources + self.persistence + self.stealth) / 4.0;
        match avg {
            x if x >= 0.8 => CapabilityLevel::Advanced,
            x if x >= 0.6 => CapabilityLevel::Intermediate,
            x if x >= 0.4 => CapabilityLevel::Basic,
            _ => CapabilityLevel::Novice,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TargetProfile {
    pub system_type: String,
    pub value: TargetValue,
    pub accessibility: AccessibilityLevel,
}

// Enums
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExploitAvailability {
    Unknown,
    Theoretical,
    Private,
    Public,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PatchStatus {
    NotPatched,
    PatchAvailable,
    PartiallyPatched,
    FullyPatched,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ImplementationStatus {
    Planned,
    InProgress,
    Implemented,
    Optimized,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PreventiveControlType {
    AccessControl,
    Encryption,
    Hardening,
    Segmentation,
    Whitelisting,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AutomationLevel {
    Manual,
    SemiAutomated,
    FullyAutomated,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ThreatMotivation {
    Financial,
    Espionage,
    Hacktivism,
    CyberWarfare,
    InsiderThreat,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CapabilityLevel {
    Novice,
    Basic,
    Intermediate,
    Advanced,
    NationState,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AttackComplexity {
    Low,
    Medium,
    High,
    VeryHigh,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DetectionDifficulty {
    Easy,
    Moderate,
    Difficult,
    VeryDifficult,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TargetValue {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AccessibilityLevel {
    Public,
    Internal,
    Restricted,
    HighlyRestricted,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Prerequisite {
    pub description: String,
    pub difficulty: PrerequisiteDifficulty,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PrerequisiteDifficulty {
    Easy,
    Medium,
    Hard,
    VeryHard,
}

// Duration type for time measurements
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Duration {
    pub hours: u32,
    pub minutes: u32,
    pub seconds: u32,
}

impl Duration {
    pub fn from_seconds(total_seconds: u32) -> Self {
        let hours = total_seconds / 3600;
        let minutes = (total_seconds % 3600) / 60;
        let seconds = total_seconds % 60;
        
        Self { hours, minutes, seconds }
    }
    
    pub fn to_seconds(&self) -> u32 {
        self.hours * 3600 + self.minutes * 60 + self.seconds
    }
}