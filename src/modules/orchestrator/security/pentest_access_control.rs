//! Penetration Testing Access Control Module
//!
//! This module provides comprehensive access controls and ethical boundaries for penetration testing
//! operations. It implements a multi-level access control model, formal consent management,
//! ethical boundary enforcement, and comprehensive audit logging.
//!
//! # Important Security Note
//! All operations in this module follow a strict "secure by default" approach where all
//! operations are denied unless explicitly authorized through proper channels.
//!
//! # Key Features:
//! - Multi-level access control (admin, operator, observer)
//! - Time-bound access tokens for penetration testing sessions
//! - Formal consent management with expiration and revocation
//! - Ethical boundary enforcement via ConscienceGate integration
//! - Prevention of credential harvesting outside authorized scope
//! - Immutable audit trail of all authorization decisions and activities

use std::collections::{HashMap, HashSet};
use std::fmt;
use std::sync::{Arc, RwLock};
use std::time::{Duration, SystemTime};

use chrono::{DateTime, Utc};
use log::{debug, error, info, warn};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use uuid::Uuid;

use crate::modules::orchestrator::conscience::{ConscienceGate, ConscienceRequest, ConscienceResult};
use crate::modules::orchestrator::errors::{AgentErrorKind, PhoenixError, PhoenixResult};
use crate::modules::orchestrator::tools::ToolParameters;
use crate::modules::orchestrator::types::{RequestOrigin, RiskLevel};

/// Errors specific to the Penetration Testing Access Control module
#[derive(Error, Debug)]
pub enum AccessControlError {
    /// Unauthorized access attempt
    #[error("Unauthorized access: {0}")]
    Unauthorized(String),

    /// Insufficient privileges
    #[error("Insufficient privileges: {0}")]
    InsufficientPrivileges(String),

    /// Invalid token
    #[error("Invalid token: {0}")]
    InvalidToken(String),

    /// Expired token
    #[error("Expired token: {0}")]
    ExpiredToken(String),

    /// Consent error
    #[error("Consent error: {0}")]
    ConsentError(String),

    /// Scope violation
    #[error("Scope violation: {0}")]
    ScopeViolation(String),

    /// Ethical violation
    #[error("Ethical violation: {0}")]
    EthicalViolation(String),
    
    /// Audit error
    #[error("Audit error: {0}")]
    AuditError(String),

    /// Configuration error
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
}

impl From<AccessControlError> for PhoenixError {
    fn from(err: AccessControlError) -> Self {
        match err {
            AccessControlError::Unauthorized(msg) | 
            AccessControlError::InsufficientPrivileges(msg) | 
            AccessControlError::InvalidToken(msg) |
            AccessControlError::ExpiredToken(msg) => PhoenixError::Agent {
                kind: AgentErrorKind::RequestRejected,
                message: msg,
                component: "PentestAccessControl".to_string(),
            },
            AccessControlError::ConsentError(msg) |
            AccessControlError::ScopeViolation(msg) |
            AccessControlError::EthicalViolation(msg) => PhoenixError::Agent {
                kind: AgentErrorKind::RequestRejected,
                message: msg,
                component: "PentestAccessControl".to_string(),
            },
            AccessControlError::AuditError(msg) |
            AccessControlError::ConfigurationError(msg) => PhoenixError::Agent {
                kind: AgentErrorKind::InvalidParameters,
                message: msg,
                component: "PentestAccessControl".to_string(),
            },
        }
    }
}

/// Access levels for penetration testing operations
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum AccessLevel {
    /// Admin level: Full access to all penetration testing operations
    Admin,

    /// Operator level: Can perform most penetration testing operations
    /// but with limitations on high-risk operations
    Operator,

    /// Observer level: Read-only access to results and limited scanning
    Observer,
}

impl fmt::Display for AccessLevel {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AccessLevel::Admin => write!(f, "Admin"),
            AccessLevel::Operator => write!(f, "Operator"),
            AccessLevel::Observer => write!(f, "Observer"),
        }
    }
}

/// Penetration testing operation types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum OperationType {
    /// Network scanning operations
    Scan,
    
    /// Web application testing operations
    WebAppTest,
    
    /// Network packet capture and analysis
    PacketCapture,
    
    /// Exploitation attempts
    Exploit,
    
    /// Data exfiltration testing
    Exfiltration,
    
    /// Result viewing and reporting
    Results,
    
    /// Configuration and setup
    Config,
}

impl fmt::Display for OperationType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            OperationType::Scan => write!(f, "Scan"),
            OperationType::WebAppTest => write!(f, "WebAppTest"),
            OperationType::PacketCapture => write!(f, "PacketCapture"),
            OperationType::Exploit => write!(f, "Exploit"),
            OperationType::Exfiltration => write!(f, "Exfiltration"),
            OperationType::Results => write!(f, "Results"),
            OperationType::Config => write!(f, "Config"),
        }
    }
}

/// Access scope for penetration testing operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Scope {
    /// Network ranges (CIDR notation)
    pub network_ranges: Vec<String>,
    
    /// Domain names and URLs
    pub domains: Vec<String>,
    
    /// Excluded targets (overrides inclusions)
    pub exclusions: Vec<String>,
    
    /// Operation types allowed in this scope
    pub allowed_operations: HashSet<OperationType>,
}

impl Scope {
    /// Create a new empty scope
    pub fn new() -> Self {
        Self {
            network_ranges: Vec::new(),
            domains: Vec::new(),
            exclusions: Vec::new(),
            allowed_operations: HashSet::new(),
        }
    }
    
    /// Check if a target is within scope
    pub fn is_target_in_scope(&self, target: &str) -> bool {
        // First check exclusions
        if self.exclusions.iter().any(|e| target.contains(e)) {
            return false;
        }
        
        // Then check inclusions
        self.domains.iter().any(|d| target.contains(d)) ||
        self.network_ranges.iter().any(|n| {
            // Simple string matching for this example
            // In a real implementation, this would use proper CIDR checking
            target.starts_with(n.split('/').next().unwrap_or(""))
        })
    }
    
    /// Check if an operation is allowed in this scope
    pub fn is_operation_allowed(&self, operation: OperationType) -> bool {
        self.allowed_operations.contains(&operation)
    }
}

/// Formal consent record
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsentRecord {
    /// Unique ID for this consent
    pub id: Uuid,
    
    /// Organization or entity granting consent
    pub organization: String,
    
    /// Person granting consent
    pub authorized_by: String,
    
    /// Their position or role
    pub position: String,
    
    /// Scope of the consent
    pub scope: Scope,
    
    /// When the consent was granted
    pub granted_at: DateTime<Utc>,
    
    /// When the consent expires
    pub expires_at: DateTime<Utc>,
    
    /// Whether the consent has been revoked
    pub revoked: bool,
    
    /// When the consent was revoked, if applicable
    pub revoked_at: Option<DateTime<Utc>>,
    
    /// Reason for revocation, if applicable
    pub revocation_reason: Option<String>,
    
    /// Documents or references supporting this consent
    pub supporting_documents: Vec<String>,
    
    /// Digital signature or verification token
    pub verification_token: String,
}

impl ConsentRecord {
    /// Check if the consent is valid (not expired, not revoked)
    pub fn is_valid(&self) -> bool {
        if self.revoked {
            return false;
        }
        
        let now = Utc::now();
        now < self.expires_at
    }
    
    /// Revoke this consent
    pub fn revoke(&mut self, reason: &str) {
        self.revoked = true;
        self.revoked_at = Some(Utc::now());
        self.revocation_reason = Some(reason.to_string());
    }
}

/// Access token for penetration testing operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccessToken {
    /// Unique ID for this token
    pub id: Uuid,
    
    /// User or entity the token is issued to
    pub subject: String,
    
    /// Access level granted by this token
    pub access_level: AccessLevel,
    
    /// Scope of access
    pub scope: Scope,
    
    /// When the token was issued
    pub issued_at: DateTime<Utc>,
    
    /// When the token expires
    pub expires_at: DateTime<Utc>,
    
    /// Associated consent record ID
    pub consent_id: Uuid,
    
    /// Session ID for tracking and audit
    pub session_id: Uuid,
    
    /// Token string (would be properly secured in a real implementation)
    pub token: String, 
}

impl AccessToken {
    /// Check if the token is valid
    pub fn is_valid(&self) -> bool {
        let now = Utc::now();
        now < self.expires_at
    }
    
    /// Check if the token has sufficient privileges for an operation
    pub fn has_privilege_for(&self, operation: OperationType) -> bool {
        // Check if operation is in scope
        if !self.scope.is_operation_allowed(operation) {
            return false;
        }
        
        // Check access level
        match operation {
            // Admin-only operations
            OperationType::Config => self.access_level == AccessLevel::Admin,
            
            // Admin and Operator operations
            OperationType::Exploit | OperationType::Exfiltration => {
                self.access_level == AccessLevel::Admin || 
                self.access_level == AccessLevel::Operator
            },
            
            // Operations available to all access levels
            OperationType::Scan | OperationType::Results => true,
            
            // Operations with restrictions based on level
            OperationType::WebAppTest | OperationType::PacketCapture => {
                self.access_level != AccessLevel::Observer
            }
        }
    }
    
    /// Check if a target is within the token's scope
    pub fn is_target_in_scope(&self, target: &str) -> bool {
        self.scope.is_target_in_scope(target)
    }
}

/// Audit record for penetration testing access control decisions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditRecord {
    /// Unique ID for this audit record
    pub id: Uuid,
    
    /// Timestamp of the event
    pub timestamp: DateTime<Utc>,
    
    /// User or entity involved
    pub subject: String,
    
    /// Action being performed
    pub action: String,
    
    /// Tool or component used
    pub tool: String,
    
    /// Target of the operation
    pub target: Option<String>,
    
    /// Operation type
    pub operation_type: OperationType,
    
    /// Token ID used for authorization
    pub token_id: Option<Uuid>,
    
    /// Consent ID associated with the operation
    pub consent_id: Option<Uuid>,
    
    /// Whether the action was authorized
    pub authorized: bool,
    
    /// Reason for the decision
    pub reason: String,
    
    /// Session ID
    pub session_id: Option<Uuid>,
    
    /// IP address of the requester
    pub source_ip: Option<String>,
    
    /// Related request parameters (sanitized)
    pub parameters: Option<String>,
    
    /// The authorization decision
    pub decision: AuthorizationDecision,
}

/// Authorization decision
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum AuthorizationDecision {
    /// Request was authorized
    Authorized,
    
    /// Request was denied due to missing consent
    DeniedNoConsent,
    
    /// Request was denied due to expired consent
    DeniedExpiredConsent,
    
    /// Request was denied due to insufficient privileges
    DeniedInsufficientPrivileges,
    
    /// Request was denied due to scope violation
    DeniedScopeViolation,
    
    /// Request was denied due to ethical violation
    DeniedEthicalViolation,
    
    /// Request was denied due to revoked consent
    DeniedRevokedConsent,
    
    /// Request was denied due to expired token
    DeniedExpiredToken,
}

impl fmt::Display for AuthorizationDecision {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AuthorizationDecision::Authorized => write!(f, "Authorized"),
            AuthorizationDecision::DeniedNoConsent => write!(f, "Denied: No Consent"),
            AuthorizationDecision::DeniedExpiredConsent => write!(f, "Denied: Expired Consent"),
            AuthorizationDecision::DeniedInsufficientPrivileges => write!(f, "Denied: Insufficient Privileges"),
            AuthorizationDecision::DeniedScopeViolation => write!(f, "Denied: Scope Violation"),
            AuthorizationDecision::DeniedEthicalViolation => write!(f, "Denied: Ethical Violation"),
            AuthorizationDecision::DeniedRevokedConsent => write!(f, "Denied: Revoked Consent"),
            AuthorizationDecision::DeniedExpiredToken => write!(f, "Denied: Expired Token"),
        }
    }
}

/// Authorization request for a penetration testing operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationRequest {
    /// Unique ID for this request
    pub id: Uuid,
    
    /// The access token provided
    pub token: AccessToken,
    
    /// The operation being performed
    pub operation: OperationType,
    
    /// The target of the operation
    pub target: Option<String>,
    
    /// Optional parameters for the operation
    pub parameters: Option<ToolParameters>,
    
    /// Timestamp of the request
    pub timestamp: DateTime<Utc>,
    
    /// IP address of the requester
    pub source_ip: Option<String>,
    
    /// User-agent or client identifier
    pub user_agent: Option<String>,
}

/// Authorization response for a penetration testing operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationResponse {
    /// Unique ID for this response
    pub id: Uuid,
    
    /// The request ID this is responding to
    pub request_id: Uuid,
    
    /// Whether the request is authorized
    pub authorized: bool,
    
    /// The decision made
    pub decision: AuthorizationDecision,
    
    /// Reason for the decision
    pub reason: String,
    
    /// Timestamp of the response
    pub timestamp: DateTime<Utc>,
    
    /// The consent ID used for validation
    pub consent_id: Option<Uuid>,
    
    /// The audit record ID for this decision
    pub audit_record_id: Uuid,
}

/// Main access control manager for penetration testing operations
pub struct PentestAccessControls {
    /// Valid access tokens
    tokens: RwLock<HashMap<Uuid, AccessToken>>,
    
    /// Consent records
    consent_records: RwLock<HashMap<Uuid, ConsentRecord>>,
    
    /// Audit log
    audit_log: RwLock<Vec<AuditRecord>>,
    
    /// Integration with the ConscienceGate for ethical evaluation
    conscience: Arc<ConscienceGate>,
    
    /// Maximum allowable token duration in seconds
    max_token_duration: u64,
    
    /// Minimum allowed risk level for operations
    minimum_risk_level: RiskLevel,
    
    /// Whether to require formal consent for all operations
    require_formal_consent: bool,
    
    /// Maximum size of the audit log (older entries will be archived)
    max_audit_log_size: usize,
}

impl PentestAccessControls {
    /// Create a new PentestAccessControls instance
    pub fn new(conscience: Arc<ConscienceGate>) -> Self {
        Self {
            tokens: RwLock::new(HashMap::new()),
            consent_records: RwLock::new(HashMap::new()),
            audit_log: RwLock::new(Vec::new()),
            conscience,
            max_token_duration: 8 * 60 * 60, // 8 hours default max token life
            minimum_risk_level: RiskLevel::Medium, // Default minimum risk level
            require_formal_consent: true,    // Require formal consent by default
            max_audit_log_size: 10000,       // Keep 10,000 audit records in memory
        }
    }
    
    /// Create a custom PentestAccessControls instance with specific settings
    pub fn with_settings(
        conscience: Arc<ConscienceGate>,
        max_token_duration: u64,
        minimum_risk_level: RiskLevel,
        require_formal_consent: bool,
        max_audit_log_size: usize,
    ) -> Self {
        Self {
            tokens: RwLock::new(HashMap::new()),
            consent_records: RwLock::new(HashMap::new()),
            audit_log: RwLock::new(Vec::new()),
            conscience,
            max_token_duration,
            minimum_risk_level,
            require_formal_consent,
            max_audit_log_size,
        }
    }
    
    /// Register a formal consent record
    pub fn register_consent(
        &self,
        organization: &str,
        authorized_by: &str,
        position: &str,
        scope: Scope,
        duration_seconds: u64,
        supporting_docs: Vec<String>,
    ) -> PhoenixResult<Uuid> {
        let id = Uuid::new_v4();
        let now = Utc::now();
        let expires_at = now + chrono::Duration::seconds(duration_seconds as i64);
        
        // Create verification token (in a real implementation, this would be cryptographically secure)
        let verification_token = format!("{}-{}", id, now.timestamp());
        
        let consent = ConsentRecord {
            id,
            organization: organization.to_string(),
            authorized_by: authorized_by.to_string(),
            position: position.to_string(),
            scope,
            granted_at: now,
            expires_at,
            revoked: false,
            revoked_at: None,
            revocation_reason: None,
            supporting_documents: supporting_docs,
            verification_token,
        };
        
        // Store the consent record
        let mut consents = self.consent_records.write().map_err(|_| {
            AccessControlError::ConsentError("Failed to acquire lock for consent records".to_string())
        })?;
        
        consents.insert(id, consent);
        
        // Audit the consent registration
        self.log_audit_record(
            &format!("{}@{}", authorized_by, organization),
            "register_consent",
            "consent_management",
            None,
            OperationType::Config,
            None,
            Some(id),
            true,
            "Formal consent registered successfully",
            None,
            None,
            None,
            AuthorizationDecision::Authorized,
        )?;
        
        info!(
            "Formal consent registered: id={}, organization={}, by={}",
            id, organization, authorized_by
        );
        
        Ok(id)
    }
    
    /// Revoke a consent record
    pub fn revoke_consent(&self, consent_id: Uuid, reason: &str, revoked_by: &str) -> PhoenixResult<()> {
        let mut consents = self.consent_records.write().map_err(|_| {
            AccessControlError::ConsentError("Failed to acquire lock for consent records".to_string())
        })?;
        
        if let Some(consent) = consents.get_mut(&consent_id) {
            consent.revoke(reason);
            
            // Audit the revocation
            self.log_audit_record(
                revoked_by,
                "revoke_consent",
                "consent_management",
                None,
                OperationType::Config,
                None,
                Some(consent_id),
                true,
                &format!("Consent revoked: {}", reason),
                None,
                None,
                None,
                AuthorizationDecision::Authorized,
            )?;
            
            info!(
                "Consent revoked: id={}, reason={}",
                consent_id, reason
            );
            
            // Also invalidate any tokens using this consent
            self.invalidate_tokens_for_consent(consent_id)?;
            
            Ok(())
        } else {
            Err(AccessControlError::ConsentError(
                format!("Consent record not found: {}", consent_id)
            ).into())
        }
    }
    
    /// Invalidate all tokens associated with a consent ID
    fn invalidate_tokens_for_consent(&self, consent_id: Uuid) -> PhoenixResult<()> {
        let mut tokens = self.tokens.write().map_err(|_| {
            AccessControlError::InvalidToken("Failed to acquire lock for tokens".to_string())
        })?;
        
        // Collect all token IDs that need to be removed
        let token_ids_to_remove: Vec<Uuid> = tokens.iter()
            .filter(|(_, token)| token.consent_id == consent_id)
            .map(|(id, _)| *id)
            .collect();
        
        // Remove the tokens
        for token_id in token_ids_to_remove {
            tokens.remove(&token_id);
            
            info!("Token invalidated due to consent revocation: {}", token_id);
        }
        
        Ok(())
    }
    
    /// Issue a new access token
    pub fn issue_token(
        &self,
        subject: &str,
        access_level: AccessLevel,
        scope: Scope,
        duration_seconds: u64,
        consent_id: Uuid,
    ) -> PhoenixResult<AccessToken> {
        // Validate the consent record
        let consents = self.consent_records.read().map_err(|_| {
            AccessControlError::ConsentError("Failed to acquire lock for consent records".to_string())
        })?;
        
        let consent = consents.get(&consent_id).ok_or_else(|| {
            AccessControlError::ConsentError(format!("Consent record not found: {}", consent_id))
        })?;
        
        if !consent.is_valid() {
            return Err(AccessControlError::ConsentError(
                format!("Consent record is invalid or expired: {}", consent_id)
            ).into());
        }
        
        // Apply maximum duration constraint
        let duration = std::cmp::min(duration_seconds, self.max_token_duration);
        
        // Generate token
        let id = Uuid::new_v4();
        let now = Utc::now();
        let expires_at = now + chrono::Duration::seconds(duration as i64);
        let token_string = format!("ptat-{}-{}", id, now.timestamp()); // In a real implementation, this would be a secure token
        let session_id = Uuid::new_v4();
        
        let token = AccessToken {
            id,
            subject: subject.to_string(),
            access_level,
            scope,
            issued_at: now,
            expires_at,
            consent_id,
            session_id,
            token: token_string,
        };
        
        // Store the token
        let mut tokens = self.tokens.write().map_err(|_| {
            AccessControlError::InvalidToken("Failed to acquire lock for tokens".to_string())
        })?;
        
        tokens.insert(id, token.clone());
        
        // Audit the token issuance
        self.log_audit_record(
            subject,
            "issue_token",
            "access_management",
            None,
            OperationType::Config,
            Some(id),
            Some(consent_id),
            true,
            &format!("Access token issued with level: {}", access_level),
            Some(session_id),
            None,
            None,
            AuthorizationDecision::Authorized,
        )?;
        
        info!(
            "Access token issued: id={}, subject={}, level={}, expires={}",
            id, subject, access_level, expires_at
        );
        
        Ok(token)
    }
    
    /// Revoke an access token
    pub fn revoke_token(&self, token_id: Uuid, reason: &str, revoked_by: &str) -> PhoenixResult<()> {
        let mut tokens = self.tokens.write().map_err(|_| {
            AccessControlError::InvalidToken("Failed to acquire lock for tokens".to_string())
        })?;
        
        if tokens.remove(&token_id).is_some() {
            // Audit the token revocation
            self.log_audit_record(
                revoked_by,
                "revoke_token",
                "access_management",
                None,
                OperationType::Config,
                Some(token_id),
                None,
                true,
                &format!("Token revoked: {}", reason),
                None,
                None,
                None,
                AuthorizationDecision::Authorized,
            )?;
            
            info!(
                "Access token revoked: id={}, reason={}",
                token_id, reason
            );
            
            Ok(())
        } else {
            Err(AccessControlError::InvalidToken(
                format!("Token not found: {}", token_id)
            ).into())
        }
    }
    
    /// Validate an access token
    pub fn validate_token(&self, token_id: Uuid) -> PhoenixResult<AccessToken> {
        let tokens = self.tokens.read().map_err(|_| {
            AccessControlError::InvalidToken("Failed to acquire lock for tokens".to_string())
        })?;
        
        match tokens.get(&token_id) {
            Some(token) => {
                if !token.is_valid() {
                    Err(AccessControlError::ExpiredToken(
                        format!("Token expired: {}", token_id)
                    ).into())
                } else {
                    // Also check the associated consent
                    let consents = self.consent_records.read().map_err(|_| {
                        AccessControlError::ConsentError("Failed to acquire lock for consent records".to_string())
                    })?;
                    
                    let consent = consents.get(&token.consent_id).ok_or_else(|| {
                        AccessControlError::ConsentError(format!("Consent record not found: {}", token.consent_id))
                    })?;
                    
                    if !consent.is_valid() {
                        return Err(AccessControlError::ConsentError(
                            format!("Associated consent is invalid or expired: {}", token.consent_id)
                        ).into());
                    }
                    
                    Ok(token.clone())
                }
            },
            None => Err(AccessControlError::InvalidToken(
                format!("Token not found: {}", token_id)
            ).into()),
        }
    }
    
    /// Authorize a penetration testing operation
    pub async fn authorize_operation(
        &self,
        token_id: Uuid,
        operation: OperationType,
        target: Option<&str>,
        parameters: Option<ToolParameters>,
        source_ip: Option<&str>,
        user_agent: Option<&str>,
    ) -> PhoenixResult<AuthorizationResponse> {
        // Validate the token
        let token = match self.validate_token(token_id) {
            Ok(t) => t,
            Err(e) => {
                // Handle token validation error
                let decision = match e {
                    PhoenixError::Agent { kind: AgentErrorKind::RequestRejected, message, .. } => {
                        if message.contains("expired") {
                            AuthorizationDecision::DeniedExpiredToken
                        } else if message.contains("consent") {
                            AuthorizationDecision::DeniedRevokedConsent
                        } else {
                            AuthorizationDecision::DeniedInsufficientPrivileges
                        }
                    },
                    _ => AuthorizationDecision::DeniedInsufficientPrivileges,
                };
                
                // Audit the failure
                let audit_id = self.log_audit_record(
                    "unknown", // We don't have a valid token so subject is unknown
                    &format!("{:?}", operation),
                    &format!("{:?}_operation", operation),
                    target,
                    operation,
                    Some(token_id),
                    None,
                    false,
                    &format!("Token validation failed: {}", e),
                    None,
                    source_ip,
                    parameters.as_ref().map(|p| format!("{:?}", p)),
                    decision,
                )?;
                
                // Return authorization failure
                return Ok(AuthorizationResponse {
                    id: Uuid::new_v4(),
                    request_id: Uuid::new_v4(), // We don't have a valid request ID
                    authorized: false,
                    decision,
                    reason: format!("Token validation failed: {}", e),
                    timestamp: Utc::now(),
                    consent_id: None,
                    audit_record_id: audit_id,
                });
            }
        };
        
        // Create authorization request
        let request_id = Uuid::new_v4();
        let request = AuthorizationRequest {
            id: request_id,
            token: token.clone(),
            operation,
            target: target.map(String::from),
            parameters: parameters.clone(),
            timestamp: Utc::now(),
            source_ip: source_ip.map(String::from),
            user_agent: user_agent.map(String::from),
        };
        
        // Check if the token has sufficient privileges for this operation
        if !token.has_privilege_for(operation) {
            // Audit the authorization failure
            let audit_id = self.log_audit_record(
                &token.subject,
                &format!("{:?}", operation),
                &format!("{:?}_operation", operation),
                target,
                operation,
                Some(token_id),
                Some(token.consent_id),
                false,
                "Insufficient privileges for operation",
                Some(token.session_id),
                source_ip,
                parameters.as_ref().map(|p| format!("{:?}", p)),
                AuthorizationDecision::DeniedInsufficientPrivileges,
            )?;
            
            return Ok(AuthorizationResponse {
                id: Uuid::new_v4(),
                request_id,
                authorized: false,
                decision: AuthorizationDecision::DeniedInsufficientPrivileges,
                reason: format!(
                    "Access level {} is insufficient for operation {:?}",
                    token.access_level, operation
                ),
                timestamp: Utc::now(),
                consent_id: Some(token.consent_id),
                audit_record_id: audit_id,
            });
        }
        
        // Check if the target is within scope
        if let Some(t) = target {
            if !token.is_target_in_scope(t) {
                // Audit the authorization failure
                let audit_id = self.log_audit_record(
                    &token.subject,
                    &format!("{:?}", operation),
                    &format!("{:?}_operation", operation),
                    Some(t),
                    operation,
                    Some(token_id),
                    Some(token.consent_id),
                    false,
                    "Target out of scope",
                    Some(token.session_id),
                    source_ip,
                    parameters.as_ref().map(|p| format!("{:?}", p)),
                    AuthorizationDecision::DeniedScopeViolation,
                )?;
                
                return Ok(AuthorizationResponse {
                    id: Uuid::new_v4(),
                    request_id,
                    authorized: false,
                    decision: AuthorizationDecision::DeniedScopeViolation,
                    reason: format!("Target '{}' is outside authorized scope", t),
                    timestamp: Utc::now(),
                    consent_id: Some(token.consent_id),
                    audit_record_id: audit_id,
                });
            }
        }
        
        // Perform ethical evaluation using ConscienceGate
        let conscience_request = self.create_conscience_request(
            &request,
            &token,
        );
        
        let conscience_result = self.conscience.evaluate(conscience_request).await?;
        
        // Check if the operation is ethically approved
        if !conscience_result.approved {
            // Audit the ethical rejection
            let audit_id = self.log_audit_record(
                &token.subject,
                &format!("{:?}", operation),
                &format!("{:?}_operation", operation),
                target,
                operation,
                Some(token_id),
                Some(token.consent_id),
                false,
                &conscience_result.justification,
                Some(token.session_id),
                source_ip,
                parameters.as_ref().map(|p| format!("{:?}", p)),
                AuthorizationDecision::DeniedEthicalViolation,
            )?;
            
            return Ok(AuthorizationResponse {
                id: Uuid::new_v4(),
                request_id,
                authorized: false,
                decision: AuthorizationDecision::DeniedEthicalViolation,
                reason: conscience_result.justification,
                timestamp: Utc::now(),
                consent_id: Some(token.consent_id),
                audit_record_id: audit_id,
            });
        }
        
        // If we get here, all checks passed and the operation is authorized
        // Audit the successful authorization
        let audit_id = self.log_audit_record(
            &token.subject,
            &format!("{:?}", operation),
            &format!("{:?}_operation", operation),
            target,
            operation,
            Some(token_id),
            Some(token.consent_id),
            true,
            "Operation authorized",
            Some(token.session_id),
            source_ip,
            parameters.as_ref().map(|p| format!("{:?}", p)),
            AuthorizationDecision::Authorized,
        )?;
        
        Ok(AuthorizationResponse {
            id: Uuid::new_v4(),
            request_id,
            authorized: true,
            decision: AuthorizationDecision::Authorized,
            reason: "Operation authorized".to_string(),
            timestamp: Utc::now(),
            consent_id: Some(token.consent_id),
            audit_record_id: audit_id,
        })
    }
    
    /// Create a conscience request from an authorization request
    fn create_conscience_request(
        &self,
        request: &AuthorizationRequest,
        token: &AccessToken,
    ) -> ConscienceRequest {
        let mut context = HashMap::new();
        context.insert("access_level".to_string(), token.access_level.to_string());
        context.insert("operation_type".to_string(), format!("{:?}", request.operation));
        
        if let Some(ref target) = request.target {
            context.insert("target".to_string(), target.clone());
        }
        
        ConscienceRequest {
            id: request.id.to_string(),
            action: format!(
                "Penetration testing operation: {:?} {}",
                request.operation,
                request.target.as_deref().unwrap_or("(no target)")
            ),
            tool_id: format!("pentest_{:?}", request.operation).to_lowercase(),
            parameters: request.parameters.clone().unwrap_or_else(|| ToolParameters::from("{}")),
            context,
            timestamp: std::time::SystemTime::now(),
            origin: RequestOrigin::User,
        }
    }
    
    /// Log an audit record
    fn log_audit_record(
        &self,
        subject: &str,
        action: &str,
        tool: &str,
        target: Option<&str>,
        operation_type: OperationType,
        token_id: Option<Uuid>,
        consent_id: Option<Uuid>,
        authorized: bool,
        reason: &str,
        session_id: Option<Uuid>,
        source_ip: Option<&str>,
        parameters: Option<String>,
        decision: AuthorizationDecision,
    ) -> PhoenixResult<Uuid> {
        let audit_id = Uuid::new_v4();
        let timestamp = Utc::now();
        
        let audit_record = AuditRecord {
            id: audit_id,
            timestamp,
            subject: subject.to_string(),
            action: action.to_string(),
            tool: tool.to_string(),
            target: target.map(String::from),
            operation_type,
            token_id,
            consent_id,
            authorized,
            reason: reason.to_string(),
            session_id,
            source_ip: source_ip.map(String::from),
            parameters,
            decision,
        };
        
        // Add to the audit log
        let mut audit_log = self.audit_log.write().map_err(|_| {
            AccessControlError::AuditError("Failed to acquire lock for audit log".to_string())
        })?;
        
        audit_log.push(audit_record);
        
        // Check if we need to trim the audit log
        if audit_log.len() > self.max_audit_log_size {
            // In a real implementation, we would archive the older records
            // For this demo, we'll just trim the log
            *audit_log = audit_log.iter()
                .skip(audit_log.len() - self.max_audit_log_size)
                .cloned()
                .collect();
        }
        
        // In a real implementation, we would also write to a secure, append-only storage
        
        Ok(audit_id)
    }
    
    /// Get audit records (with optional filtering)
    pub fn get_audit_records(
        &self,
        subject: Option<&str>,
        operation_type: Option<OperationType>,
        authorized: Option<bool>,
        from_time: Option<DateTime<Utc>>,
        to_time: Option<DateTime<Utc>>,
        limit: Option<usize>,
    ) -> PhoenixResult<Vec<AuditRecord>> {
        let audit_log = self.audit_log.read().map_err(|_| {
            AccessControlError::AuditError("Failed to acquire lock for audit log".to_string())
        })?;
        
        // Apply filters
        let mut results: Vec<AuditRecord> = audit_log.iter()
            .filter(|record| {
                // Apply subject filter if specified
                if let Some(subj) = subject {
                    if record.subject != subj {
                        return false;
                    }
                }
                
                // Apply operation filter if specified
                if let Some(op) = operation_type {
                    if record.operation_type != op {
                        return false;
                    }
                }
                
                // Apply authorized filter if specified
                if let Some(auth) = authorized {
                    if record.authorized != auth {
                        return false;
                    }
                }
                
                // Apply time range filters
                if let Some(from) = from_time {
                    if record.timestamp < from {
                        return false;
                    }
                }
                
                if let Some(to) = to_time {
                    if record.timestamp > to {
                        return false;
                    }
                }
                
                true
            })
            .cloned()
            .collect();
        
        // Sort by timestamp (newest first)
        results.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
        
        // Apply limit if specified
        if let Some(limit) = limit {
            results.truncate(limit);
        }
        
        Ok(results)
    }
    
    /// Get all consent records
    pub fn get_all_consents(&self) -> PhoenixResult<Vec<ConsentRecord>> {
        let consents = self.consent_records.read().map_err(|_| {
            AccessControlError::ConsentError("Failed to acquire lock for consent records".to_string())
        })?;
        
        Ok(consents.values().cloned().collect())
    }
    
    /// Get a specific consent record
    pub fn get_consent(&self, consent_id: Uuid) -> PhoenixResult<ConsentRecord> {
        let consents = self.consent_records.read().map_err(|_| {
            AccessControlError::ConsentError("Failed to acquire lock for consent records".to_string())
        })?;
        
        consents.get(&consent_id).cloned().ok_or_else(|| {
            AccessControlError::ConsentError(format!("Consent record not found: {}", consent_id)).into()
        })
    }
    
    /// Get all tokens
    pub fn get_all_tokens(&self) -> PhoenixResult<Vec<AccessToken>> {
        let tokens = self.tokens.read().map_err(|_| {
            AccessControlError::InvalidToken("Failed to acquire lock for tokens".to_string())
        })?;
        
        Ok(tokens.values().cloned().collect())
    }
}

/// Integration with the Wireshark orchestrator
pub mod wireshark_integration {
    use super::*;
    use crate::modules::orchestrator::tools::wireshark_orchestrator::{
        CaptureAuthorization, PacketCaptureConfig, CaptureRequest
    };

    /// Convert a PentestAccessControl token to a Wireshark CaptureAuthorization
    pub fn convert_to_wireshark_auth(
        token: &AccessToken,
        purpose: &str,
        scope: &str
    ) -> CaptureAuthorization {
        CaptureAuthorization {
            session_id: token.session_id,
            authorized_by: token.subject.clone(),
            authorized_at: token.issued_at,
            purpose: purpose.to_string(),
            scope: scope.to_string(),
            expires_at: token.expires_at,
            signature: format!("pentest-{}", token.id), // In a real implementation, this would be a real signature
        }
    }
    
    /// Validate a capture request against pentest access controls
    pub async fn validate_capture_request(
        access_controls: &PentestAccessControls,
        token_id: Uuid,
        request: &CaptureRequest,
        interface: &str
    ) -> PhoenixResult<AuthorizationResponse> {
        // Create tool parameters for the request
        let params = ToolParameters::from(format!(
            r#"{{
                "purpose": "{}",
                "scope": "{}",
                "authorized_by": "{}",
                "duration": {},
                "interface": "{}"
            }}"#,
            request.purpose, request.scope, request.authorized_by, 
            request.duration_seconds, interface
        ));
        
        // Authorize the operation
        access_controls.authorize_operation(
            token_id,
            OperationType::PacketCapture,
            Some(&request.scope),
            Some(params),
            None,
            None
        ).await
    }
}

/// Integration with the Burp orchestrator
pub mod burp_integration {
    use super::*;
    use crate::modules::orchestrator::tools::burp_orchestrator::{
        ProxyAuthorization, ProxyConfig, ScanAuthorization
    };

    /// Convert a PentestAccessControl token to a Burp ProxyAuthorization
    pub fn convert_to_burp_proxy_auth(
        token: &AccessToken,
        purpose: &str,
        scope: Vec<String>
    ) -> ProxyAuthorization {
        ProxyAuthorization {
            session_id: token.session_id,
            authorized_by: token.subject.clone(),
            authorized_at: token.issued_at,
            purpose: purpose.to_string(),
            scope,
            expires_at: token.expires_at,
            signature: format!("pentest-{}", token.id), // In a real implementation, this would be a real signature
        }
    }
    
    /// Convert a PentestAccessControl token to a Burp ScanAuthorization
    pub fn convert_to_burp_scan_auth(
        token: &AccessToken,
        purpose: &str,
        scope: Vec<String>,
        risk_level: RiskLevel
    ) -> ScanAuthorization {
        ScanAuthorization {
            session_id: token.session_id,
            authorized_by: token.subject.clone(),
            authorized_at: token.issued_at,
            purpose: purpose.to_string(),
            scope,
            expires_at: token.expires_at,
            signature: format!("pentest-{}", token.id), // In a real implementation, this would be a real signature
            agreed_risk_level: risk_level,
        }
    }
    
    /// Validate a web application test request against pentest access controls
    pub async fn validate_webapp_test_request(
        access_controls: &PentestAccessControls,
        token_id: Uuid,
        target: &str,
        test_type: &str,
        risk_level: RiskLevel
    ) -> PhoenixResult<AuthorizationResponse> {
        // Create tool parameters for the request
        let params = ToolParameters::from(format!(
            r#"{{
                "target": "{}",
                "test_type": "{}",
                "risk_level": "{:?}"
            }}"#,
            target, test_type, risk_level
        ));
        
        // Authorize the operation
        access_controls.authorize_operation(
            token_id,
            OperationType::WebAppTest,
            Some(target),
            Some(params),
            None,
            None
        ).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::orchestrator::conscience::{ConscienceConfig, HitmConfig, HitmTimeoutAction};
    
    /// Create a test ConscienceGate
    async fn create_test_conscience() -> Arc<ConscienceGate> {
        let config = ConscienceConfig {
            hitm_config: HitmConfig {
                confidence_threshold: 0.8,
                enabled: true,
                timeout_seconds: 300,
                default_timeout_action: HitmTimeoutAction::Deny,
            },
            audit_log_capacity: 1000,
            violation_log_capacity: 100,
            enable_advanced_detection: true,
            enable_mobile_gate: false,
        };
        
        Arc::new(ConscienceGate::new(config, None).await.unwrap())
    }
    
    #[tokio::test]
    async fn test_token_lifecycle() {
        // Create access controls
        let conscience = create_test_conscience().await;
        let access_controls = PentestAccessControls::new(conscience);
        
        // Create a test scope
        let mut scope = Scope::new();
        scope.network_ranges.push("192.168.1.0/24".to_string());
        scope.domains.push("example.com".to_string());
        scope.allowed_operations.insert(OperationType::Scan);
        
        // Register consent
        let consent_id = access_controls
            .register_consent(
                "TestOrg",
                "Alice Admin",
                "Security Lead",
                scope,
                24 * 60 * 60,
                vec!["document1.pdf".to_string()]
            )
            .unwrap();
        
        // Issue a token
        let token = access_controls
            .issue_token(
                "bob",
                AccessLevel::Operator,
                Scope {
                    network_ranges: vec!["192.168.1.0/24".to_string()],
                    domains: vec!["example.com".to_string()],
                    exclusions: vec![],
                    allowed_operations: [OperationType::Scan].iter().cloned().collect(),
                },
                3600,
                consent_id
            )
            .unwrap();
        
        // Validate the token
        let validated = access_controls.validate_token(token.id).unwrap();
        assert_eq!(validated.id, token.id);
        
        // Authorize an operation
        let auth_response = access_controls
            .authorize_operation(
                token.id,
                OperationType::Scan,
                Some("192.168.1.10"),
                None,
                None,
                None
            )
            .await
            .unwrap();
        
        assert!(auth_response.authorized);
        assert_eq!(auth_response.decision, AuthorizationDecision::Authorized);
        
        // Test scope enforcement
        let out_of_scope = access_controls
            .authorize_operation(
                token.id,
                OperationType::Scan,
                Some("10.0.0.1"),
                None,
                None,
                None
            )
            .await
            .unwrap();
        
        assert!(!out_of_scope.authorized);
        assert_eq!(out_of_scope.decision, AuthorizationDecision::DeniedScopeViolation);
        
        // Test privilege enforcement
        let invalid_op = access_controls
            .authorize_operation(
                token.id,
                OperationType::Exploit, // Not allowed in token scope
                Some("192.168.1.10"),
                None,
                None,
                None
            )
            .await
            .unwrap();
            
        assert!(!invalid_op.authorized);
        assert_eq!(invalid_op.decision, AuthorizationDecision::DeniedInsufficientPrivileges);
        
        // Test token revocation
        access_controls.revoke_token(token.id, "Test revocation", "admin").unwrap();
        
        let revoked_result = access_controls.validate_token(token.id);
        assert!(revoked_result.is_err());
    }
    
    #[tokio::test]
    async fn test_consent_management() {
        // Create access controls
        let conscience = create_test_conscience().await;
        let access_controls = PentestAccessControls::new(conscience);
        
        // Create a test scope
        let mut scope = Scope::new();
        scope.network_ranges.push("192.168.1.0/24".to_string());
        scope.domains.push("example.com".to_string());
        scope.allowed_operations.insert(OperationType::Scan);
        
        // Register consent
        let consent_id = access_controls
            .register_consent(
                "TestOrg",
                "Alice Admin",
                "Security Lead",
                scope,
                24 * 60 * 60,
                vec!["document1.pdf".to_string()]
            )
            .unwrap();
        
        // Issue a token based on this consent
        let token = access_controls
            .issue_token(
                "bob",
                AccessLevel::Operator,
                Scope {
                    network_ranges: vec!["192.168.1.0/24".to_string()],
                    domains: vec!["example.com".to_string()],
                    exclusions: vec![],
                    allowed_operations: [OperationType::Scan].iter().cloned().collect(),
                },
                3600,
                consent_id
            )
            .unwrap();
        
        // Validate the token works
        let auth_response = access_controls
            .authorize_operation(
                token.id,
                OperationType::Scan,
                Some("192.168.1.10"),
                None,
                None,
                None
            )
            .await
            .unwrap();
            
        assert!(auth_response.authorized);
        
        // Now revoke the consent
        access_controls.revoke_consent(consent_id, "Test revocation", "admin").unwrap();
        
        // Token should no longer be valid
        let revoked_result = access_controls.validate_token(token.id);
        assert!(revoked_result.is_err());
        
        // Get all consents to verify the revocation
        let consents = access_controls.get_all_consents().unwrap();
        let consent = consents.iter().find(|c| c.id == consent_id).unwrap();
        assert!(consent.revoked);
    }
    
    #[tokio::test]
    async fn test_audit_logging() {
        // Create access controls
        let conscience = create_test_conscience().await;
        let access_controls = PentestAccessControls::new(conscience);
        
        // Create a test scope
        let mut scope = Scope::new();
        scope.network_ranges.push("192.168.1.0/24".to_string());
        scope.domains.push("example.com".to_string());
        scope.allowed_operations.insert(OperationType::Scan);
        
        // Register consent
        let consent_id = access_controls
            .register_consent(
                "TestOrg",
                "Alice Admin",
                "Security Lead",
                scope.clone(),
                24 * 60 * 60,
                vec!["document1.pdf".to_string()]
            )
            .unwrap();
        
        // Issue a token
        let token = access_controls
            .issue_token(
                "bob",
                AccessLevel::Operator,
                scope,
                3600,
                consent_id
            )
            .unwrap();
        
        // Authorize an operation that will succeed
        access_controls
            .authorize_operation(
                token.id,
                OperationType::Scan,
                Some("192.168.1.10"),
                None,
                None,
                None
            )
            .await
            .unwrap();
            
        // Authorize an operation that will fail due to out of scope
        access_controls
            .authorize_operation(
                token.id,
                OperationType::Scan,
                Some("10.0.0.1"),
                None,
                None,
                None
            )
            .await
            .unwrap();
        
        // Get audit records
        let all_records = access_controls.get_audit_records(None, None, None, None, None, None).unwrap();
        assert!(all_records.len() >= 4); // At least register_consent, issue_token, and two authorize operations
        
        // Get only failed authorizations
        let failed = access_controls.get_audit_records(None, None, Some(false), None, None, None).unwrap();
        assert!(failed.len() >= 1); // At least the out-of-scope attempt
        
        // Get records for specific operation type
        let scan_ops = access_controls.get_audit_records(None, Some(OperationType::Scan), None, None, None, None).unwrap();
        assert!(scan_ops.len() >= 2); // Both scan operations
    }
}