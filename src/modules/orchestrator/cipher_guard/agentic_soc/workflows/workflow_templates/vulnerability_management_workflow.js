/**
 * Rapid7 Critical Vulnerability Workflow
 *
 * Trigger: Rapid7 or normalized critical vulnerability events. Coordinates:
 *  - L1 vulnerability assessment (exploitability, exposure, adjusted score)
 *  - L2 vulnerability management (central record, SLA, priority)
 *  - Jira ticket creation
 *  - SLA follow-up scheduling
 *  - Status event emission
 */

/**
 * @type {import('../workflow_engine').WorkflowDefinition}
 */
const vulnerabilityManagementWorkflow = {
    name: 'vulnerability_management_critical',
    trigger: ['rapid7:vuln:critical', 'vuln:critical'],
    description: 'Critical vulnerability workflow integrating Rapid7, L1/L2 vuln agents, Jira, and SLA tracking.',
    steps: [
        {
            id: 'l1_vuln_assessment',
            description:
                'L1 Vulnerability assessment via vuln_scanner_agent to compute exploitability, exposure, and adjusted score.',
            retry: 1,
            timeoutMs: 20000,
            async run(context, helpers) {
                const vulnEvent = context.eventPayload || context.vulnerability || {};
                const rapid7 = helpers.integrations && helpers.integrations.rapid7;

                // Optionally fetch enrichment from Rapid7 if configured
                let rapid7Details = null;
                if (rapid7 && typeof rapid7.getVulnerabilities === 'function' && vulnEvent.assetId) {
                    try {
                        const vulns = await rapid7.getAssetVulnerabilities
                            ? await rapid7.getAssetVulnerabilities(vulnEvent.assetId, { cve: vulnEvent.cve })
                            : await rapid7.getVulnerabilities({ cve: vulnEvent.cve, limit: 1 });
                        rapid7Details = Array.isArray(vulns) && vulns[0] ? vulns[0] : null;
                    } catch (err) {
                        if (helpers.messageBus) {
                            await helpers.messageBus.publish('workflow:warning', {
                                workflow: 'vulnerability_management_critical',
                                step: 'l1_vuln_assessment',
                                message: `Rapid7 enrichment failed: ${err.message}`,
                            });
                        }
                    }
                }

                try {
                    await helpers.invokeAgent('vuln_scanner_agent', {
                        type: 'vulnerability_assessment',
                        source: vulnEvent.source || 'rapid7',
                        vulnerability: vulnEvent,
                        rapid7Details,
                    });
                } catch (err) {
                    if (helpers.messageBus) {
                        await helpers.messageBus.publish('workflow:warning', {
                            workflow: 'vulnerability_management_critical',
                            step: 'l1_vuln_assessment',
                            message: `Error invoking vuln_scanner_agent: ${err.message}`,
                        });
                    }
                }

                const severity = (vulnEvent.severity || 'critical').toString().toLowerCase();

                return {
                    id: vulnEvent.id || `vuln-${Date.now()}`,
                    cve: vulnEvent.cve || null,
                    title: vulnEvent.title || 'Critical vulnerability',
                    description: vulnEvent.description || '',
                    assetId: vulnEvent.assetId || vulnEvent.asset_id || null,
                    assetName: vulnEvent.assetName || vulnEvent.hostname || vulnEvent.host,
                    severity,
                    cvssScore: vulnEvent.cvssScore || vulnEvent.cvss_score || 9.0,
                    exploitabilityScore: vulnEvent.exploitabilityScore || 85,
                    exposureScore: vulnEvent.exposureScore || 75,
                    adjustedRiskScore:
                        vulnEvent.adjustedRiskScore ||
                        Math.min(
                            100,
                            (vulnEvent.cvssScore || 9.0) * 8 +
                                (vulnEvent.exploitabilityScore || 85) * 0.1 +
                                (vulnEvent.exposureScore || 75) * 0.1,
                        ),
                    raw: vulnEvent,
                    rapid7Details,
                };
            },
        },
        {
            id: 'l2_vuln_management',
            description:
                'L2 Vulnerability Management agent creates/updates central record and computes SLA and priority.',
            retry: 1,
            timeoutMs: 20000,
            async run(context, helpers) {
                const l1 = context.stepResults.l1_vuln_assessment || {};
                const severity = l1.severity || 'critical';

                let l2Result;
                try {
                    await helpers.invokeAgent('vuln_management_agent', {
                        type: 'vulnerability_management',
                        vulnerability: l1,
                    });

                    // Simulated management decision summary
                    const baseSlaDays = {
                        critical: 7,
                        high: 30,
                        medium: 90,
                        low: 180,
                    };

                    const slaDays = baseSlaDays[severity] || baseSlaDays.critical;
                    const priority =
                        severity === 'critical'
                            ? 'P1'
                            : severity === 'high'
                            ? 'P2'
                            : severity === 'medium'
                            ? 'P3'
                            : 'P4';

                    l2Result = {
                        recordId: `vm-${l1.id}`,
                        ownerTeam: l1.assetName && l1.assetName.includes('db') ? 'database-team' : 'infrastructure-team',
                        slaDays,
                        priority,
                        dueDate: new Date(Date.now() + slaDays * 24 * 60 * 60 * 1000).toISOString(),
                    };
                } catch (err) {
                    l2Result = {
                        recordId: `vm-${l1.id}`,
                        ownerTeam: 'unknown',
                        slaDays: 7,
                        priority: 'P1',
                        dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
                        note: `L2 vuln_management_agent invocation failed: ${err.message}`,
                    };
                }

                return l2Result;
            },
        },
        {
            id: 'jira_ticket',
            description: 'Create prioritized Jira task assigned to appropriate patch owner.',
            retry: 1,
            timeoutMs: 20000,
            async run(context, helpers) {
                const jira = helpers.integrations && helpers.integrations.jira;
                if (!jira || typeof jira.createIssue !== 'function') {
                    return {
                        created: false,
                        reason: 'Jira connector not configured',
                    };
                }

                const l1 = context.stepResults.l1_vuln_assessment || {};
                const l2 = context.stepResults.l2_vuln_management || {};

                const title = `[${l1.severity ? l1.severity.toUpperCase() : 'CRITICAL'}] ${
                    l1.cve || 'Critical vulnerability'
                } on ${l1.assetName || l1.assetId || 'unknown asset'}`;

                const descriptionLines = [
                    `CVE: ${l1.cve || 'n/a'}`,
                    `Asset: ${l1.assetName || l1.assetId || 'unknown'}`,
                    `Severity: ${l1.severity || 'critical'} (CVSS ${l1.cvssScore || 'n/a'})`,
                    `Adjusted risk score: ${l1.adjustedRiskScore ?? 'n/a'}`,
                    `Exploitability score: ${l1.exploitabilityScore ?? 'n/a'}`,
                    `Exposure score: ${l1.exposureScore ?? 'n/a'}`,
                    '',
                    `Owner team: ${l2.ownerTeam || 'unknown'}`,
                    `SLA: remediate within ${l2.slaDays || '?'} days (due by ${l2.dueDate || 'n/a'})`,
                ];

                const data = {
                    type: 'vulnerability',
                    title,
                    description: descriptionLines.join('\n'),
                    severity: l1.severity || 'critical',
                    cvssScore: l1.cvssScore,
                    cve: l1.cve,
                    category: 'vulnerability_management',
                    technicalDetails: JSON.stringify(
                        {
                            l1Assessment: l1,
                            l2Management: l2,
                        },
                        null,
                        2,
                    ),
                };

                const result = await jira.createIssue(data, {
                    customFields: {
                        sla_days: (l2 && l2.slaDays) || 7,
                        owner_team: l2.ownerTeam || 'unknown',
                    },
                });

                return {
                    created: true,
                    issueKey: result.issueKey,
                    issueUrl: result.issueUrl,
                };
            },
        },
        {
            id: 'sla_followup_registration',
            description:
                'Register SLA follow-up check in scheduler (modeled via schedule events) for monitoring and escalation.',
            timeoutMs: 10000,
            async run(context, helpers) {
                const l1 = context.stepResults.l1_vuln_assessment || {};
                const l2 = context.stepResults.l2_vuln_management || {};
                const jiraTicket = context.stepResults.jira_ticket || {};

                // Emit a notional scheduling event. A real implementation would talk
                // to the core scheduler directly.
                await helpers.emitEvent('schedule:vuln_sla_check', {
                    vulnerabilityId: l1.id,
                    cve: l1.cve,
                    severity: l1.severity,
                    slaDays: l2.slaDays,
                    dueDate: l2.dueDate,
                    jiraIssueKey: jiraTicket.issueKey,
                    ownerTeam: l2.ownerTeam,
                });

                return {
                    scheduled: true,
                    dueDate: l2.dueDate,
                };
            },
        },
        {
            id: 'status_reporting',
            description: 'Emit creation and initial status events for downstream observability.',
            async run(context, helpers) {
                const l1 = context.stepResults.l1_vuln_assessment || {};
                const l2 = context.stepResults.l2_vuln_management || {};
                const jiraTicket = context.stepResults.jira_ticket || {};

                const basePayload = {
                    vulnerabilityId: l1.id,
                    cve: l1.cve,
                    severity: l1.severity,
                    assetId: l1.assetId,
                    assetName: l1.assetName,
                    adjustedRiskScore: l1.adjustedRiskScore,
                    ownerTeam: l2.ownerTeam,
                    slaDays: l2.slaDays,
                    dueDate: l2.dueDate,
                    jiraIssueKey: jiraTicket.issueKey || null,
                    timestamp: new Date().toISOString(),
                };

                await helpers.emitEvent('vuln:workflow:created', basePayload);
                await helpers.emitEvent('vuln:workflow:status', {
                    ...basePayload,
                    status: 'registered',
                });

                return {
                    emitted: true,
                };
            },
        },
    ],
};

module.exports = vulnerabilityManagementWorkflow;