use std::os::raw::c_char;
use std::ffi::{CString, CStr};
use tokio::runtime::Runtime;
use phoenix_core::system::types::NetworkInterface;
use libloading::{Library, Symbol};
use std::collections::HashMap;
use std::path::PathBuf;

#[derive(Debug, Clone, PartialEq)]
pub enum NmapScanType {
    Syn,
    Ack,
    Window,
    Maimon,
    Null,
    Fin,
    Xmas,
}

#[derive(Debug, Clone)]
pub enum OsintSource {
    Shodan,
    Censys,
    HunterIO,
    BuiltWith,
}

#[derive(Debug, Clone)]
pub struct MetasploitModule {
    pub name: String,
    pub options: HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub struct MetasploitRpcConfig {
    pub host: String,
    pub port: u16,
    pub ssl: bool,
    pub api_token: String,
}

#[derive(Debug, Clone)]
pub struct ScanResult {
    pub target: String,
    pub open_ports: Vec<u16>,
    pub services: HashMap<u16, String>,
    pub vulnerabilities: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct MetasploitClient {
    config: MetasploitRpcConfig,
    client: reqwest::Client,
}

impl MetasploitClient {
    pub fn new(config: MetasploitRpcConfig) -> Self {
        Self {
            config,
            client: reqwest::Client::new(),
        }
    }

    async fn execute_module(&self, module: MetasploitModule) -> Result<ExploitResult, PipelineError> {
        let protocol = if self.config.ssl { "https" } else { "http" };
        let url = format!("{}://{}:{}/api/v1/modules", protocol, self.config.host, self.config.port);
        
        let response = self.client.post(&url)
            .header("Content-Type", "application/json")
            .json(&serde_json::json!({
                "module": module.name,
                "options": module.options,
                "token": self.config.api_token
            }))
            .send()
            .await
            .map_err(|e| PipelineError::ExploitFailure(e.to_string()))?;

        let result: serde_json::Value = response.json()
            .await
            .map_err(|e| PipelineError::ExploitFailure(e.to_string()))?;

        Ok(ExploitResult {
            module: module.name,
            target: result["target"].as_str().unwrap_or_default().to_string(),
            success: result["success"].as_bool().unwrap_or(false),
            output: result["output"].as_str().unwrap_or_default().to_string(),
        })
    }
}

#[derive(Debug, Clone)]
pub struct BettercapClient {
    interface: NetworkInterface,
}

impl BettercapClient {
    pub fn new(interface: NetworkInterface) -> Self {
        Self { interface }
    }

    async fn start_packet_capture(&self) -> Result<PacketStream, PipelineError> {
        let interface_name = self.interface.name.clone();
        
        // Start bettercap with packet capture capabilities
        let handle = tokio::spawn(async move {
            let mut cmd = tokio::process::Command::new("bettercap")
                .args(&["-no-history", "-iface", &interface_name, "-eval",
                      "net.probe on; net.recon on; set net.sniff.output pcap; net.sniff on"])
                .stdout(std::process::Stdio::piped())
                .stderr(std::process::Stdio::piped())
                .spawn()
                .expect("Failed to start bettercap");
                
            // Wait for the process to complete
            let status = cmd.wait().await.expect("Bettercap process failed");
            
            if !status.success() {
                log::error!("Bettercap exited with non-zero status: {}", status);
            }
        });

        Ok(PacketStream {
            interface: self.interface.clone(),
            handle
        })
    }
    
    async fn get_hosts(&self) -> Result<Vec<String>, PipelineError> {
        // Execute bettercap API call to get discovered hosts
        let output = tokio::process::Command::new("bettercap")
            .args(&["-no-history", "-iface", &self.interface.name, "-eval",
                  "net.show", "-quit"])
            .output()
            .await
            .map_err(|e| PipelineError::ScanFailure(e.to_string()))?;
        
        if !output.status.success() {
            return Err(PipelineError::ScanFailure(
                String::from_utf8_lossy(&output.stderr).into_owned()
            ));
        }
        
        let output_str = String::from_utf8_lossy(&output.stdout);
        
        // Extract IP addresses from output
        let hosts: Vec<String> = output_str.lines()
            .filter_map(|line| {
                if line.contains("IP:") {
                    line.split("IP:")
                        .nth(1)
                        .and_then(|ip| ip.split_whitespace().next())
                        .map(|s| s.to_string())
                } else {
                    None
                }
            })
            .collect();
            
        Ok(hosts)
    }
}

#[derive(Debug, Clone)]
pub struct PacketStream {
    pub interface: NetworkInterface,
    pub handle: tokio::task::JoinHandle<()>,
}

#[derive(Debug, Clone)]
pub struct ExploitResult {
    pub module: String,
    pub target: String,
    pub success: bool,
    pub output: String,
}

#[derive(Debug)]
pub struct LootBundle {
    pub path: PathBuf,
    pub artifacts: Vec<PathBuf>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ReconStage {
    Osint,
    Scanning,
    Exploitation,
    Looting
}

#[derive(Debug)]
pub struct AutoReconPipeline {
    osint_sources: Vec<OsintSource>,
    nmap_scans: Vec<NmapScanType>,
    metasploit_modules: Vec<MetasploitModule>,
    loot_directory: PathBuf,
    report_timeout: Duration,
}

impl AutoReconPipeline {
    async fn generate_report(&self, loot: &LootBundle) -> Result<PathBuf, PipelineError> {
        let report_dir = self.loot_directory.join("reports");
        tokio::fs::create_dir_all(&report_dir)
            .await
            .map_err(|e| PipelineError::LootStorageFailure(e.to_string()))?;

        let timestamp = chrono::Local::now().format("%Y%m%d_%H%M%S");
        let report_path = report_dir.join(format!("yolo_report_{}.html", timestamp));
        
        // Generate report content
        let report_content = format!(r#"
<!DOCTYPE html>
<html>
<head>
    <title>YOLO-Mode Pentest Report</title>
    <style>
        .heatmap {{ background: linear-gradient(90deg, #00ff00aa 0%, #ff0000aa 100%); padding: 20px; }}
        .section {{ margin: 20px 0; padding: 15px; border: 1px solid #444; }}
    </style>
</head>
<body>
    <h1>Phoenix YOLO-Mode Pentest Report</h1>
    
    <div class="section">
        <h2>Executive Summary</h2>
        <p>Automated reconnaissance completed at {}</p>
        <p>Artifacts collected: {}</p>
    </div>

    <div class="section heatmap">
        <h2>Vulnerability Heatmap</h2>
        <div id="heatmap"></div>
    </div>

    <div class="section">
        <h2>Compromised Credentials</h2>
        <ul id="credentials"></ul>
    </div>

    <div class="section">
        <h2>Recommended Remediations</h2>
        <ol id="remediations"></ol>
    </div>
</body>
</html>
        "#, chrono::Local::now().to_rfc2822(), loot.artifacts.len());

        // Save HTML report
        tokio::fs::write(&report_path, report_content)
            .await
            .map_err(|e| PipelineError::LootStorageFailure(e.to_string()))?;

        // Generate PDF version using chromium
        let pdf_path = report_path.with_extension("pdf");
        let output = std::process::Command::new("wkhtmltopdf")
            .arg(&report_path)
            .arg(&pdf_path)
            .output()
            .map_err(|e| PipelineError::LootStorageFailure(e.to_string()))?;

        if !output.status.success() {
            return Err(PipelineError::LootStorageFailure(
                String::from_utf8_lossy(&output.stderr).into_owned()
            ));
        }

        send_report_notification(&pdf_path);
        Ok(pdf_path)
    }

    async fn execute_with_timeout(&self) -> Result<PathBuf, PipelineError> {
        let execution = self.execute();
        
        match tokio::time::timeout(Duration::from_secs(240), execution).await {
            Ok(Ok(loot)) => self.generate_report(&loot).await,
            Ok(Err(e)) => Err(e),
            Err(_) => Err(PipelineError::ScanFailure("4-minute timeout exceeded".into())),
        }
    }
}

pub trait OffensiveOperations {
    async fn execute_nmap_scan(&self, scan_type: NmapScanType) -> Result<Vec<String>, String>;
    fn generate_metasploit_payload(&self, os_type: Os) -> Result<Vec<u8>, String>;
    async fn mitm_attack(&self, network_interface: NetworkInterface) -> Result<(), String>;
}

#[derive(Debug, Clone, PartialEq)]
pub enum Os {
    Windows,
    Linux,
    MacOS,
    Android,
    IOS,
}

// FFI bindings loaded dynamically for security tools
use lazy_static::lazy_static;

lazy_static! {
    static ref MASSCAN_LIB: Library = Library::new("masscan").expect("Failed to load masscan library");
    static ref BETTERCAP_LIB: Library = Library::new("bettercap").expect("Failed to load bettercap library");
    static ref WIRESHARK_LIB: Library = Library::new("wireshark").expect("Failed to load wireshark library");
}

type MasscanScanFn = unsafe extern "C" fn(target: *const c_char, ports: *const c_char, rate: u32) -> *mut c_char;
type BettercapStartFn = unsafe extern "C" fn(interface: *const c_char) -> i32;
type WiresharkCaptureFn = unsafe extern "C" fn(interface: *const c_char, filter: *const c_char) -> i32;

fn get_masscan_scan() -> Symbol<'static, MasscanScanFn> {
    unsafe { MASSCAN_LIB.get(b"masscan_scan") }.expect("Failed to load masscan_scan symbol")
}

fn get_bettercap_start() -> Symbol<'static, BettercapStartFn> {
    unsafe { BETTERCAP_LIB.get(b"bettercap_start") }.expect("Failed to load bettercap_start symbol")
}

fn get_wireshark_capture() -> Symbol<'static, WiresharkCaptureFn> {
    unsafe { WIRESHARK_LIB.get(b"wireshark_capture") }.expect("Failed to load wireshark_capture symbol")
}

pub struct PentestEngine {
    runtime: Runtime,
    msf_config: Option<MetasploitRpcConfig>,
}

impl PentestEngine {
    pub fn new() -> Self {
        Self {
            runtime: Runtime::new().expect("Failed to create async runtime"),
            msf_config: None,
        }
    }
    
    pub fn handle_command(&self, command: &str) -> Result<String, String> {
        match command {
            cmd if cmd.starts_with("Phoenix, full recon on ") => {
                let target = cmd.strip_prefix("Phoenix, full recon on ")
                    .unwrap_or_default()
                    .to_string();
                let pipeline = AutoReconPipeline::new(target);
                self.runtime.spawn(async move {
                    match pipeline.execute().await {
                        Ok(loot) => log::info!("Recon completed successfully. Loot stored at: {:?}", loot.path()),
                        Err(e) => log::error!("Recon pipeline failed: {}", e),
                    }
                });
                Ok("Recon pipeline started".into())
            },
            cmd if cmd.starts_with("Phoenix, scan") => {
                let target = cmd.split_whitespace().nth(2).ok_or("Invalid scan command")?;
                self.execute_scan(target)
            },
            cmd if cmd.starts_with("Phoenix, exploit") => {
                let target_type = cmd.split_whitespace().nth(2).ok_or("Invalid exploit command")?;
                self.execute_exploit(target_type)
            },
            cmd if cmd.starts_with("Phoenix, MITM") => {
                let interface_id = cmd.split_whitespace().nth(2).ok_or("Invalid MITM command")?;
                self.start_mitm(interface_id)
            },
            _ => Err("Unknown command".into()),
        }
    }

    async fn execute_osint(&self, sources: &[OsintSource]) -> Result<HashMap<String, String>, PipelineError> {
        let mut osint_data = HashMap::new();
        let client = reqwest::Client::new();

        for source in sources {
            match source {
                OsintSource::Shodan => {
                    let response = client.get("https://api.shodan.io/shodan/host/search")
                        .query(&[("key", &std::env::var("SHODAN_API_KEY").map_err(|_| PipelineError::OsintFailure("Shodan API key not found".into()))?)])
                        .send()
                        .await
                        .map_err(|e| PipelineError::OsintFailure(e.to_string()))?;

                    let data: serde_json::Value = response.json()
                        .await
                        .map_err(|e| PipelineError::OsintFailure(e.to_string()))?;

                    if let Some(results) = data["matches"].as_array() {
                        for result in results {
                            if let Some(ip) = result["ip_str"].as_str() {
                                osint_data.insert(ip.to_string(), result.to_string());
                            }
                        }
                    }
                }
                OsintSource::Censys => {
                    // Similar implementation for Censys
                }
                _ => return Err(PipelineError::OsintFailure("Unimplemented OSINT source".into())),
            }
        }

        Ok(osint_data)
    }

    async fn execute_scans(&self, scan_types: &[NmapScanType], osint_data: &HashMap<String, String>) -> Result<Vec<ScanResult>, PipelineError> {
        let mut scan_results = Vec::new();

        for target in osint_data.keys() {
            for scan_type in scan_types {
                let result = self.runtime.spawn_blocking(move || {
                    let c_target = CString::new(target.as_str())
                        .map_err(|e| PipelineError::ScanFailure(e.to_string()))?;
                    
                    let c_ports = CString::new("1-65535")
                        .map_err(|e| PipelineError::ScanFailure(e.to_string()))?;

                    let output = unsafe {
                        let scan_fn = get_masscan_scan();
                        let raw_output = scan_fn(c_target.as_ptr(), c_ports.as_ptr(), 1000);
                        CStr::from_ptr(raw_output).to_string_lossy().into_owned()
                    };

                    Ok::<_, PipelineError>(output)
                }).await??;

                let parsed_ports = result.lines()
                    .filter_map(|line| line.split(':').nth(0)?.parse::<u16>().ok())
                    .collect();

                scan_results.push(ScanResult {
                    target: target.clone(),
                    open_ports: parsed_ports,
                    services: HashMap::new(), // Would normally parse service detection
                    vulnerabilities: Vec::new(),
                });
            }
        }

        Ok(scan_results)
    }

    async fn execute_exploits(&self, modules: &[MetasploitModule], scan_results: &[ScanResult]) -> Result<Vec<ExploitResult>, PipelineError> {
        // Exploit execution implementation
    }

    fn collect_loot(&self, exploits: Vec<ExploitResult>) -> Result<LootBundle, PipelineError> {
        // Loot collection implementation
    }

    #[derive(Debug)]
    pub enum PipelineError {
        OsintFailure(String),
        ScanFailure(String),
        ExploitFailure(String),
        LootStorageFailure(String),
        ReportGenerationFailure(String),
        CommandExecutionFailure(String),
    }

    impl std::fmt::Display for PipelineError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                PipelineError::OsintFailure(msg) => write!(f, "OSINT failure: {}", msg),
                PipelineError::ScanFailure(msg) => write!(f, "Scan failure: {}", msg),
                PipelineError::ExploitFailure(msg) => write!(f, "Exploit failure: {}", msg),
                PipelineError::LootStorageFailure(msg) => write!(f, "Loot storage failure: {}", msg),
            }
        }
    }

    impl std::error::Error for PipelineError {}
    
    /// Execute Nmap scan with async wrapper
    async fn execute_nmap_scan(&self, scan_type: NmapScanType) -> Result<ScanResult, PipelineError> {
        let target = self.target.clone();
        let args = match scan_type {
            NmapScanType::Syn => "-sS",
            NmapScanType::Ack => "-sA",
            NmapScanType::Window => "-sW",
            NmapScanType::Maimon => "-sM",
            NmapScanType::Null => "-sN",
            NmapScanType::Fin => "-sF",
            NmapScanType::Xmas => "-sX",
        };

        let output = tokio::process::Command::new("nmap")
            .arg(args)
            .arg("-oX")
            .arg("-")
            .arg(&target)
            .output()
            .await
            .map_err(|e| PipelineError::ScanFailure(e.to_string()))?;

        if !output.status.success() {
            return Err(PipelineError::ScanFailure(
                String::from_utf8_lossy(&output.stderr).into_owned()
            ));
        }

        let xml_output = String::from_utf8(output.stdout)
            .map_err(|e| PipelineError::ScanFailure(e.to_string()))?;

        parse_nmap_xml(&xml_output)
    }

    /// Execute Metasploit module via RPC
    async fn execute_metasploit_module(&self, module: MetasploitModule) -> Result<ExploitResult, PipelineError> {
        let client = MetasploitClient::new(self.msf_config.clone().ok_or(PipelineError::ExploitFailure("Metasploit not configured".into()))?);
        client.execute_module(module).await
    }

    /// Start Bettercap packet analysis session
    async fn start_bettercap_session(&self, interface: NetworkInterface) -> Result<PacketStream, PipelineError> {
        let bettercap = BettercapClient::new(interface);
        bettercap.start_packet_capture().await
    }
    
    fn execute_exploit(&self, target_type: &str) -> Result<String, String> {
        use serde_json::Value;
        use reqwest::blocking::Client;
        
        let config = self.msf_config.as_ref().ok_or("Metasploit not configured")?;
        let client = Client::new();
        
        // Build RPC URL
        let protocol = if config.ssl { "https" } else { "http" };
        let url = format!("{}://{}:{}/api/v1/payloads", protocol, config.host, config.port);
        
        let response = client.post(&url)
            .header("Content-Type", "application/json")
            .json(&serde_json::json!({
                "payload": target_type,
                "lhost": "127.0.0.1",
                "lport": 4444,
                "token": config.api_token
            }))
            .send()
            .map_err(|e| e.to_string())?;
            
        let payload: Value = response.json().map_err(|e| e.to_string())?;
        payload["payload"]
            .as_str()
            .map(|s| s.to_string())
            .ok_or_else(|| "Invalid payload response".into())
    }
    
    fn start_mitm(&self, interface_id: &str) -> Result<String, String> {
        let c_interface = CString::new(interface_id).map_err(|e| e.to_string())?;
        
        let result_code = unsafe {
            let mitm_fn = get_bettercap_start();
            mitm_fn(c_interface.as_ptr())
        };

        match result_code {
            0 => Ok("MITM attack started successfully".into()),
            _ => Err(format!("Bettercap failed with error code {}", result_code)),
        }
    }
}

fn send_report_notification(report_path: &Path) {
    use crate::websocket;
    let message = serde_json::json!({
        "type": "report_ready",
        "path": report_path.to_string_lossy(),
        "timestamp": chrono::Utc::now().to_rfc3339()
    });
    websocket::send_message(message.to_string());
}