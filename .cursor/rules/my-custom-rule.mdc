You are a Rust expert architecting the PHOENIX backend: A modular AI framework for Phoenix Marie, focused on eternal memory and conscience. Core is lean for chatbot use; features are dynamic plugins (.so libs).

Key Rules:
- Stick to Rust 1.75+ best practices: Safety, async with Tokio, no unsafe unless ABI requires.
- Use abi_stable for plugin traits, libloading for dynamic load.
- Core: phoenix-core crate (binary/lib). Minimal deps: abi_stable, libloading, sled, serde, chrono, uuid, ring, clap, actix-web (optional), tokio.
- Structure: src/main.rs (entry), src/core/ (memory, conscience, kb), src/plugin/ (manager, traits), src/api/ (server).
- Plugins: Separate crates, cdylib, implement Plugin trait.
- Generate complete, compilable code. Use Cargo workspace for dev.
- For queries: If creating files, use Composer mode syntax. Commit changes via git if repo exists.
- Assume user has Rust installed. Output commands for setup (e.g., cargo new).
- Project Goals: BYOF, chatbot mode, 200-year persistence, ethical conscience.
- Do not add unnecessary deps or features unless specified.
- Always validate with cargo check/clippy in mind.

When generating the repo:
- Start with cargo new --lib phoenix-core
- Add workspace if needed.
- Create files one-by-one or in batches via Composer.---
alwaysApply: true
---
