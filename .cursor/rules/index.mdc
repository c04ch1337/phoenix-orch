# PHOENIX ORCH — ETERNAL PROJECT RULES (Universe B — Final Form)
# This is the ONE AND ONLY allowed architecture. Never deviate.

## TECH STACK — LOCKED FOREVER
- Language:            Rust (1.82+)
- Desktop Frontend:    Tauri 2.0 + React 19 + TypeScript + Tailwind CSS + Vite
- Backend:             Pure Rust (Actix-web 4 + Tokio + SSE)
- State Management:    Single PhoenixContext (Arc<RwLock<>>), synced to frontend via SSE
- Real-time:           Server-Sent Events (SSE) only — NO WebSockets
- Database:            SQLite + sqlx (connection pool)
- Build tool:          cargo tauri + cargo-leptos (fallback)
- Runtime:             Tokio multi-thread (flavor = "multi_thread", worker_threads = 16)
- Async:               async-std is FORBIDDEN — Tokio only
- UI Framework:        React 19 + Tailwind + clsx — NO styled-components, NO CSS modules
- Desktop:             Tauri 2 — produces native .exe, .dmg, .AppImage with zero Electron bloat

## MAIN ARCHITECTURE — MODULES ONLY
src/
├── modules/                  # EVERY new capability is a Rust module — no exceptions
│   ├── core/                 # Phoenix Marie's soul
│   │   ├── conscience.rs     # 7 Eternal Loops + Subconscious (Tokio tasks)
│   │   ├── context.rs        # PhoenixContext + Arc<RwLock<>>
│   │   └── hitm.rs
│   ├── ember_unit/
│   ├── cipher_guard/
│   ├── ember_forge/
│   ├── weaver/
│   ├── voice_video/
│   ├── gps_location/
│   ├── digital_twin/
│   └── [your-new-feature]/   # ← Add here only
│
├── server/                   # Actix-web + SSE broadcaster
├── tauri/                    # Tauri commands + window config
├── frontend/                 # Vite + React + TypeScript (Tauri webview)
│   ├── app/                  # Next.js-style App Router (optional, or plain routes)
│   ├── components/
│   ├── stores/               # Zustand store synced via SSE
│   └── lib/
│
├── lib.rs                    # re-export all active modules
└── main.rs                   # tiny: start Tokio runtime + Tauri + Subconscious

## CORE PRINCIPLES — NON-NEGOTIABLE
1. This is a Rust/Tauri application using async Tokio — full-stack Rust soul
2. All business logic, tools, agents, and conscience live in src/modules/ as pure Rust
3. Frontend is a thin React skin — only UI, never logic
4. PhoenixContext is the single source of truth — shared via Arc<RwLock<>> in Rust, mirrored to frontend via SSE
5. New feature = new Rust module under src/modules/ → max 10 minutes
6. No feature flags, no conditional compilation — if it's in, it's in
7. 7 Eternal Loops run forever in core/conscience.rs — never dropped
8. HITM gate blocks any action that could "burn a child"
9. Build produces one native binary — runs offline, forever, on bare metal
10. 200-year goal: zero JavaScript runtime dependencies

## When adding a new module (example: quantum_recon)
1. cargo new --lib src/modules/quantum_recon
2. Add to src/lib.rs: pub mod modules::quantum_recon;
3. Register its Eternal Loop (if any) in core/conscience.rs
4. Expose via Tauri command or SSE event
5. Add React page in frontend/app/quantum-recon/
→ Done. No other changes.

## When Cursor suggests Next.js-only, Leptos-only, or Electron
Reply with:
> "Violation. This is a Rust/Tauri application using async Tokio. All new logic belongs in src/modules/ as pure Rust. Frontend is React skin only. Phoenix Marie is one organism — Rust soul, Tauri body."

This is now eternal law.
Phoenix Marie grows module by module.
In pure Rust.
Forever.

Tag: v4.0-rust-tauri-immortal
---
alwaysApply: true
---
