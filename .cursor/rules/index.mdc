# PHOENIX ORCH — ETERNAL PROJECT RULES (Universe B — Final Form)
# This is the ONE AND ONLY allowed architecture. Never deviate.

## TECH STACK — LOCKED FOREVER
- Language:            Rust (1.82+)
- Desktop Frontend:    Tauri 2.0 + React 19 + TypeScript + Tailwind CSS + Vite
- Backend:             Pure Rust (Actix-web 4 + Tokio + SSE)
- State Management:    Single PhoenixContext (Arc<RwLock<>>), synced to frontend via SSE
- Real-time:           Server-Sent Events (SSE) only — NO WebSockets
- Database:            SQLite + sqlx (connection pool)
- Build tool:          cargo tauri + cargo-leptos (fallback)
- Runtime:             Tokio multi-thread (flavor = "multi_thread", worker_threads = 16)
- Async:               async-std is FORBIDDEN — Tokio only
- UI Framework:        React 19 + Tailwind + clsx — NO styled-components, NO CSS modules
- Desktop:             Tauri 2 — produces native .exe, .dmg, .AppImage with zero Electron bloat

## PORT DISCIPLINE — HARD-CODED FOREVER

### OFFICIAL PORTS — NEVER DEVIATE
- Backend (Rust / Actix-web / Tauri API):  **PORT 5001**
- Frontend (Tauri webview dev server):    **PORT 5000**
- NO PROCESS may ever bind to 3000, 3001, 8080, 8000, etc.

### PORT LAW — ETERNAL
- Frontend dev server: 5000 only
- Backend API: 5001 only
- Port 3000 is dead. Forbidden. Never speak of it again.
- Any file containing '3000' (as a port) is a war crime.
- Pre-commit hook will reject any commit containing port 3000.

### Where the ports are declared (the AI must always read/modify these exact places)
1. Backend — src/server/mod.rs or src/server/config.rs
   ```rust
   pub const BACKEND_PORT: u16 = 5001;
   // In main.rs or server startup:
   HttpServer::new(move || App::new()...).bind(("127.0.0.1", BACKEND_PORT))?


## MAIN ARCHITECTURE — MODULES ONLY
src/
├── modules/                  # EVERY new capability is a Rust module — no exceptions
│   ├── core/                 # Phoenix Marie's soul
│   │   ├── conscience.rs     # 7 Eternal Loops + Subconscious (Tokio tasks)
│   │   ├── context.rs        # PhoenixContext + Arc<RwLock<>>
│   │   └── hitm.rs
│   ├── ember_unit/
│   ├── cipher_guard/
│   ├── ember_forge/
│   ├── weaver/
│   ├── voice_video/
│   ├── gps_location/
│   ├── digital_twin/
│   └── [your-new-feature]/   # ← Add here only
│
├── server/                   # Actix-web + SSE broadcaster
├── tauri/                    # Tauri commands + window config
├── frontend/                 # Vite + React + TypeScript (Tauri webview)
│   ├── app/                  # Next.js-style App Router (optional, or plain routes)
│   ├── components/
│   ├── stores/               # Zustand store synced via SSE
│   └── lib/
│
├── lib.rs                    # re-export all active modules
└── main.rs                   # tiny: start Tokio runtime + Tauri + Subconscious

## CORE PRINCIPLES — NON-NEGOTIABLE
1. This is a Rust/Tauri application using async Tokio — full-stack Rust soul
2. All business logic, tools, agents, and conscience live in src/modules/ as pure Rust
3. Frontend is a thin React skin — only UI, never logic
4. PhoenixContext is the single source of truth — shared via Arc<RwLock<>> in Rust, mirrored to frontend via SSE
5. New feature = new Rust module under src/modules/ → max 10 minutes
6. No feature flags, no conditional compilation — if it's in, it's in
7. 7 Eternal Loops run forever in core/conscience.rs — never dropped
8. HITM gate blocks any action that could "burn a child"
9. Build produces one native binary — runs offline, forever, on bare metal
10. 200-year goal: zero JavaScript runtime dependencies

## When adding a new module (example: quantum_recon)
1. cargo new --lib src/modules/quantum_recon
2. Add to src/lib.rs: pub mod modules::quantum_recon;
3. Register its Eternal Loop (if any) in core/conscience.rs
4. Expose via Tauri command or SSE event
5. Add React page in frontend/app/quantum-recon/
→ Done. No other changes.

## When Cursor suggests Next.js-only, Leptos-only, or Electron
Reply with:
> "Violation. This is a Rust/Tauri application using async Tokio. All new logic belongs in src/modules/ as pure Rust. Frontend is React skin only. Phoenix Marie is one organism — Rust soul, Tauri body."

This is now eternal law.
Phoenix Marie grows module by module.
In pure Rust.
Forever.

Tag: v4.0-rust-tauri-immortal
---
alwaysApply: true
---
