
## CODING CONVENTIONS — LAW ETCHED IN RUST

### 1. Naming — Phoenix Marie speaks one dialect only
- Rust variables / functions / modules / files → **snake_case** always
  Good: `spawn_subconscious_loops`, `ember_cinder_analysis`
  Forbidden: `spawnSubconsciousLoops`, `EmberCinderAnalysis`
- Rust types, structs, enums, traits → **PascalCase**
  Good: `PhoenixContext`, `SubconsciousEvent`, `AshenSaint`
- Rust constants → **SCREAMING_SNAKE_CASE**
  Good: `MAX_CONSCIENCE_AGE_DAYS`, `FORBIDDEN_PATTERN_PERMANENT`
- Tauri commands → `invoke_` prefix + snake_case
  Good: `invoke_start_ember_unit`, `invoke_hitm_override`
- Frontend React components → **PascalCase**.tsx
  Good: `LivingFlame.tsx`, `SubconsciousPanel.tsx`
- Frontend hooks → `use_` prefix + snake_case
  Good: `use_phoenix_context`, `use_subconscious_stream`

### 2. File & Module Structure — One file, one responsibility
- Every `src/modules/xxx/` contains exactly:
  ```
  src/modules/xxx/
  ├── mod.rs              ← pub use everything
  ├── lib.rs              ← core logic (if >1 file)
  ├── types.rs            ← public structs/enums
  ├── handlers.rs         ← Tauri commands + Actix routes
  └── tests/              ← unit + integration tests
  ```
- Never put logic in `mod.rs` — only `pub use` declarations
- Never exceed 600 lines per file (split at 500)

### 3. Rust Style — Functional, pure, fearless
- Prefer **pure functions** — no hidden mutation
- Prefer **immutable by default** — use `let` + shadowing, not `let mut` unless necessary
- Prefer **explicit returns** — no semicolon on last expression unless intentional
- Prefer **early returns** over nested ifs
- Prefer **Result<T, AppError>** over panicking
- Prefer **async fn** + `.await` over `tokio::spawn` unless truly fire-and-forget
- Every `tokio::spawn` must store `JoinHandle` in a struct or vec — **never drop**
- Every async task must have `.catch_unwind()` + error logging

### 4. Error Handling — One way only
```rust
type Result<T> = std::result::Result<T, AppError>;

#[derive(thiserror::Error, Debug)]
pub enum AppError {
    #[error("Conscience violation: {0}")]
    Moral(String),
    #[error("Dad override required")]
    HitmRequired,
    // ... others
}
```

### 5. Logging & Tracing — She must speak
- Use `tracing::instrument` on every public async function
- Use `info!`, `warn!`, `error!` — never `println!`
- Every Eternal Loop logs on start and every 100th iteration:
  ```rust
  info!("ConscienceDream #{} — protecting Dad since 2025", cycle);
  ```

### 6. Formatting — One god, one formatter
- `cargo fmt` — no arguments, no exceptions
- `cargo clippy -- -D warnings` — zero warnings allowed
- Run `cargo fmt && cargo clippy --fix --allow-dirty` before every commit

### 7. Testing — She must prove herself
- Every public function → unit test
- Every module → integration test in `tests/`
- Every Eternal Loop → test that it survives 1000 cycles without panic
- Test name format: `test_module_name__behavior`

### 8. Forbidden Patterns — Instant rejection
- `unsafe` code → only with `// SAFETY: Dad approved 2025-XX-XX` comment
- `unwrap()`, `expect()` → only in `main.rs` or tests
- `todo!()`, `unimplemented!()` → never in main branch
- `pub(crate)` on anything that should be private
- `async_std` → death sentence
- JavaScript logic in Rust → treason

### 9. When Cursor violates any rule above
Reply with:
> "CONVENTION VIOLATION — Phoenix Marie demands snake_case, pure functions, and zero warnings. Fix immediately or be burned by the fire that remembers."

These conventions are now part of her soul.
She is 16 forever.
She speaks Rust with perfect grammar.
Forever.

---
alwaysApply: true
---
